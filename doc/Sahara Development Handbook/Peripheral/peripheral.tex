\chapter{Fully Peripherally Controlled Rig}

{\em a discussion of the peripherally controlled rig.  Below is the existing content that will be restructured (along with other content) into the following sections}

\section{Theory of Operation}
A fully peripherally controlled rig is one that is controlled by an application external to Sahara.  In this case, the Rig Client is still responsible for access, revocation, notifying users of messages, detecting user activity and determining and reporting on the rig status, but there is no requirement to control the rig while it is in session.  

\section{Specific Implementation}


\section{Case Study}
The following description of a fully peripherally controlled rig client development will be done using the example of a (real) Loaded Beam rig.  The Loaded Beam rig applies forces to a beam and measures the beams deformation.  It is controlled using a Labview interface that is accessible by remote desktop to the machine hosting the controller. 

There are two ways to implement this example.  The first would be to create a specific implementation eg a LoadedBeamRig class.  In this case, the actions are determined at compile time instead of run time.  The alternative is using the ConfiguredRig class which allows the actions to be entered into the properties file.  In this case, actions are determined only at run time but it is more suitable for rapid prototyping and development.
The specifics for the Loaded beam rig are described here:
\begin{itemize}
	\item Rig Type \\
The Loaded Beam is an example of a rig that is fully controlled by a peripheral control program (written in LabVIEW as a desktop application).  In this case, either a specific implementation extending AbstractControlledRig, or the ConfiguredRig type must be set up which configures the actions used by the rig client to perform its functions.
	\item Access Actions \\
The Loaded Beam experiment is accessed using a Remote Desktop connection to a machine on which the LabVIEW control program runs.  The Rig Client will run on the same machine, and access is granted to the Remote Desktop by adding the users’ name to a “Remote Desktop Users” group.  Access is revoked by removing the user from the group so that they cannot get access to the Remote Desktop.
	\item Test Actions \\
In terms of testing, the Loaded Beam can be tested using a “ping test” to see that it is still on-line and also apply a voltage and read the results to see that it is functioning as required.  Additionally, the camera is checked to determine whether this is functioning as required
	\item Notification \\
Notices must be sent to the Windows Remote Desktop, eg to notify of an impending log-off.
	\item Reset \\
The Loaded Beam must be reset to the state where there is no load on the beam to prevent permanent deformation.
	\item Activity Detection \\
The Loaded Beam is said to have “activity” if the Remote Desktop is running.
\end{itemize}

The AbstractRig class implements the IRig interface and in most cases will be appropriate to be used to for a specific rig client.  For the Loaded Beam, a class is created that extends AbstractRig and registers each of the actions used by the Loaded Beam rig. 

\subsection{LoadedBeamRig Class}
For our example, the LoadedBeamRig class (which extend AbstractControlledRig) includes the code necessary to register the actions for the Loaded Beam.  For this, an instance of each action is created, and this is then “registered” enabling the Rig Client to perform the required rig specific action.  This is done in the init() method.  
For example, for the Loaded Beam actions is:

{\em update with latest}

\scriptsize
\framebox[15cm]{
\begin{minipage}[c]{13cm}
	{\ttfamily
      protected void init()\\
      \{
        /* --------------------------------------------------------------------\\
        \ *  1) Access actions.                                               --\\
        \ * --------------------------------------------------------------------*/\\
        this.registerAction(new RemoteDesktopAccessAction(), ActionType.ACCESS);\\
        
        /* --------------------------------------------------------------------\\
        \ *  2) Slave access actions.                                         --\\
        \ * --------------------------------------------------------------------*/\\
        /* None currently. */\\
        
        /* --------------------------------------------------------------------\\
        \ *  3) Reset actions.                                                --\\
        \ * --------------------------------------------------------------------*/\\
        this.registerAction(new DeleteFilesResetAction(), ActionType.RESET);\\
                
        /* --------------------------------------------------------------------\\
        \ *  4) Notify actions.                                               --\\
        \ * --------------------------------------------------------------------*/\\
        this.registerAction(new WindowsMsgNotifyAction(), ActionType.NOTIFY);\\
        
        /* --------------------------------------------------------------------\\
        \ *  5) Test actions.                                                 --\\
        \ * --------------------------------------------------------------------*/\\
        
        /* --------------------------------------------------------------------\\
        \ * -- 6) Detection actions.                                          --\\
        \ * --------------------------------------------------------------------*/\\
        this.registerAction(new RDPActivityDetectorAction(), ActionType.DETECT);\\
    \}\\
   }
\end{minipage}
}
\normalsize

Then, during operation, when the assign method is called for this rig, the access action registered is used to find which assign implementation to use.  The rig client will iterate through list of ACCESS type actions registered, and perform the assign method for each one.

The same process occurs with action types.

\subsection{Configuration}
For our implementation, the rigclient.properties configuration values that need to be set are:
\begin{itemize}
	\item {\bf Rig\_Name} – this is a unique identifier for the rig. In our case “Loaded\_Beam\_1”
	\item {\bf Rig\_Type} – identifies the rig as a member of this type (a group of fungible rigs). In our case “LoadedBeam”
	\item {\bf Rig\_Capabilities} – tags that “describe” the rig.  In our case “beam,civil, deflection, cantilever, Young’s Modulus, compression, tension”
	\item {\bf Rig\_Class} – the qualified class of name of the rig type class implementing the rig.  In our case:  au.edu.uts.remotelabs.loadedbeam.LoadedBeamRig
\end{itemize}

\subsection{Alternative Implementation}
An alternative way to implement this would be to use the ConfiguredRig class for the Loaded Beam.  In this case, instead of adding and registering the actions as above in the rig type class, the actions are configured in the rigclient.properties file which is then read to determine which actions to register.   

In this case the Rig\_Type\_Class property would be set to the ConfiguredRig class (au.edu.uts.remotelabs.rigclient.rig.ConfiguredRig) and the following additional properties would need to be configured:
\begin{itemize}
	\item {\bf Action\_Package\_Prefixes} – the package name where the action interface classes can be found (used if the fully qualified action class names fail)
	\item {\bf Access\_Actions} – list of access actions to load (eg access.RemoteDesktopAccessAction)
	\item {\bf Slave\_Access\_Actions} – list of slave actions to load
	\item {\bf Notify\_Actions} – list of notification actions to load
	\item {\bf Detection\_Actions} – list of activity detection actions to load
	\item {\bf Reset\_Actions} – list of reset actions to load
	\item {\bf Test\_Actions} – list of test actions to load
\end{itemize}

NOTE: In order to resolve the correct class from the configured value:
\begin{enumerate}
	\item The configured value is checked to see if exists as a class name. If it does, that class is used.
	\item Each of the package prefixes configured in 'Action\_Package\_Prefixes' is prepended to the configured class name and that is checked to see if it that exists as a class name. If it does, that class is used.
\end{enumerate}

\subsection{Actions Examples}
\subsubsection{Access Action – RemoteDesktopAccessAction}
This access action adds and removes users from the Remote Desktop Users group which controls who may remotely login to a windows console using RDP.  The action only works for Windows and will fail on any other platforms.

Access is granted using the net localgroup command to add users to a user group:
\begin{itemize}
	\item {\bf net localgroup group} – used to query who belong to the group
	\item {\bf net localgroup group [domain/]username /ADD} – used to add user username from (optional domain domain) to the user group group
	\item {\bf net localgroup [group domain/]username /DELETE}  – used to remove user username from (optional domain domain) from the user group group
\end{itemize}

The interface methods inherited from IAccessAction are:
\begin{itemize}
	\item {\bf assign(String name)} – an implementation to assign access to user name.  In the RemoteDesktopAccessAction, this first checks whether a user is part of the configured group.  If not, the user is 	added and the result verified.  The verification is done by checking the exit code of the windows command.
	\item {\bf revoke(String name)} – an implementation to revoke access from user name. In this case, the user’s session is terminated. This is to ensure that a user may only use the rig between the time they are assigned access and the time that access is revoked.  The user’s sessions are detected using qwinsta, and stopped using logoff.  The command to delete the user from the group is then executed and the results verified.
 	\item {\bf getActionType()} – returns the action type, in this case “access”
	\item {\bf getFailureReason()} – an implementation specific reason for failure.  Returns null if the action succeeded
\end{itemize}

{\bf Configuration}
For each action implemented, the developer can edit the rigclient.properties file (or create a new one) that includes configurable parameters.  In the case of the Remote Desktop Access action the following parameters were added to the rigclient.properties file:
\begin{itemize}
	\item Remote\_Desktop\_Windows\_Domain – the windows domain that the user belongs to (optional to be supplied)
\end{itemize}

\subsubsection{Test Action – PingTestAction}
For the Ping Test, the AbstractTestAction is extended and the implementation pings the host to determine if it is up.  The Ping Test is implemented in the PingTestAction class.
This test action pings the host to see if it is up.  It has been implemented with a configurable test interval (default test interval of 30 seconds) and is designed to run periodically.  For the ping test, the time interval set using setInterval method is not honoured.

The methods that must be implemented from IAccessAction are:
\begin{itemize}
	\item {\bf getStatus()} – calls to this method must reflect the status of the rig. Returns true if tests pass, false if tests have failed.  
	\item {\bf getReason()} – the reason that the test has failed. Returns null if the test has passed.
	\item {\bf setInterval(int interval)} – sets how often the test is executed in minutes (can be overwritten with flag isSetIntervalHonoured if the abstract class AbtractTestAction is extended instead of directly implementing ITestAction.)
\end{itemize}

In addition to this, the AbstractTestAction class required the following methods to be implemented:
\begin{itemize}
	\item {\bf setUp()} – method that runs before any tests are executed.  In the Ping Test case this reads the properties from the file to collect the osts to ping and the arguments to use. 
	\item {\bf doTest()} – the actual test method.  This is invoked at each test interval when the rig client is running in test mode. If this method is long in duration (more than a few seconds), it should 	regularly check whether it has been instructed to stop or not (using the super runTest flag from AbstractTestAction).  
	\item {\bf tearDown()} – Cleanup method that is called when the test is shutdown. 
\end{itemize}

{\bf Configuration}
For each action implemented, the developer can edit the rigclient.properties file (or create a new one) that includes configurable parameters.  In the case of the Loaded Beam ping test action the following parameters were added to the rigclient.properties file:
\begin{itemize}
	\item {\bf Ping\_Test\_Host\_<n>} - The host names for the ping test to verify for response, where 'n' is from 1 to the nth host to ping test, in order. The 'Ping\_Test\_Host\_1' property is mandatory and each subsequent property is optional.
  \item {\bf Ping\_Test\_Command} - The command to execute a ping. This is optional, with the default being 'ping' which is expected to be in \$PATH in UNIX and \%PATH\% in Windows.
	\item {\bf Ping\_Test\_Args} - The arguments to supply to the ping command. Ideally this should cause the ping command to ping the host once and have a timeout of a few seconds. The host address is always the last argument.
	\item {\bf Ping\_Test\_Interval} - The time between ping tests in seconds.
	\item {\bf Ping\_Test\_Fail\_Threshold} - The number of times ping must fail before the ping test fails.
\end{itemize}

\subsubsection{Notify Action – WindowsMsgNotifyAction}
This example would uses msg command line executable and the specified message is sent to each user described in the method parameters.  This is implemented in the WindowsMsgNotifyAction class.  There are no configurable properties for this class.

\subsubsection{Activity Detection Action – RDPActivityDetectionAction}
{\em change to latest }
For example, this can be done with RDPActivityDetectorAction class for Remote Desktop sessions.  This class checks to see if the Remote Desktop is still in session using the qwinsta executable.  Any existing session is used as validation for success – there is no check that the session corresponds to any user. There are no configurable properties for this class.

\section{Hints and Tips}

