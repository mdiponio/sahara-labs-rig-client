% Tania Machet
% University of Technology, Sydney
% LabShare
% Sahara Development Handbook

\chapter{Development Approach} 

{\em a discussion of how to to approach development for Sahara, figuring out what you need to develop, howit is structured etc.  Below is the existing content that may go here, work to be done on putting the right chapters in the correct sections and adding latest revioew comments.  Rig CLient struceture - here or previous chapter?}

\section{Purpose} 
The rig client translates the abstract concept of rig operations as requested by the scheduling server into specific rig behaviour.  The development of the rig client specifies what constitutes this behaviour. 

\section{Requirements }
In order to start developing the rig client the following design decisions should be made about the rig’s design:
\begin{enumerate}
	\item {\bf How is singular access granted to a user?}
	
There must be a mechanism whereby a user can be given access to a rig and no other (unauthorised) user can access the rig during this time.  

For example: a rig can be accessed using a remote desktop as a proxy to the control interface.  In this case, the remote desktop allows the user to be “remote” and by adding a single user to the 'Remote Desktop Users' group access is granted to the control application. This group is used by Windows Terminal Services to grant access to Remote Desktops. As a restriction is set to prohibit other users login access, only the assigned user can use the rig.

	\item {\bf How is the rig controlled, and what constraints are there?}
	
If the rig already exists and is already computer controlled, there will not be a need to duplicate control using the rig client.

If the rig does not yet exists consider the following:
			\begin{itemize}
				\item Will the rig be interactive or can it be used without the user being present (eg controlled by uploading an instruction file)?
				\item Will an interactive rig have its own implemented control interface? This is often suitable when there is a standard industry control interface (e.g. off-the-shelf PLC controllers) or an easily implemented application (e.g. LabView application).
				\item If there is no available control interface, does the rig have an applicable API for use with Java (i.e. Java, JVM hosted or JNI capable)?   This would allow direct control using the Rig Client if suitable for the rig type. NOTE:  Direct control is not suitable for rigs that require high fidelity (i.e. consistent timing and rapid responses) as it is implemented using HTTP requests and the timing is variable and cannot be guaranteed.
	\end{itemize}

	\item {\bf What tests will be used to determine whether the rig is in a usable state?}
	
It is desired that the rig determine its own status as being ready to assign to a user.  This requires decisions on what constitutes being 'ready for use' for the specific rig.  Tests to determine this readiness can include, for example:
			\begin{itemize}
				\item Existence (network, device nodes) - can the device be contacted. 
				\item Environment (power, air pressure) - does the current operating environment support the needs of the rig. 
				\item Hardware (pistons, actuators, solenoids, motors) - can the hardware be commanded to be perform its desired actions. 
				\item Sensor (LVDS, magnetostrictive, temperature, time) - does a change in the hardware’s state generate the desired measurable result with the tolerance of the sensors
		  \end{itemize}
\end{enumerate}

\subsection{Additional (optional) functions that can be considered}
\begin{enumerate}
	\item {\bf What actions (if any) need to be performed to reset the rig? }
	
If it is important that the rig be in a known state before the next session starts, or if leaving it in certain states is damaging to the rig, this needs to be included.
	\item {\bf What requirements are there to allow users to be notified of status/update messages while controlling the rig?}
	
Messages concerning the status of a session or any updates the user needs should be directed to the rig control interface as that is where the users’ attention will be.  This may require a notification implementation (eg messages to be sent to a Windows or UNIX console session to generate an operating system notification dialogue).
	\item {\bf What method (if any) will be used to determine whether a user is actively using the session they have been granted?}
	
This is used, for example, to end sessions of idle users.  An example of this would be to determine whether or not the user has actually logged into the Remote Desktop console for the rig they have a session for.
	\item {\bf How (if at all) slave access will be granted to users?}
	
Does the activity being designed for require slave users to be granted access, and if so how will this be done?  (NOTE: The collaboration model between multiple users is a master – slave model. The master user is the session initiator and the user who can terminate a session. Slave users can be assigned access to a session to either passively view the session or actively participate in rig control.) 
	\item {\bf How can activity or use be detected from the rig?}
\end{enumerate}

To free rigs it that are  assigned but not actively being used, the laboratory software needs to know whether the rig is actually being used. It is not possible to reliably determine this without knowing the context of the rigs so it is up to rig author to implement activity detection (with no specific activity detection implementation, the assumption is there is always activity). Some options to detect this are:
\begin{itemize}
	\item Windows or UNIX console session list
	\item Some explicit control to turn on use, which may timeout.
\end{itemize}

\section{Web Interface Development Approach}
{\em taken from original other section - must be modified}\\

The Sahara approach to a customisable interface allows institute specific partial scripts to be written that can customise an institution’s site, and the rig type pages.

The partial scripts are created in an appropriate directory with the name of the institution (which must match the configured institution in the config.ini file.  For UTS, this directory would be: INSTALL\_DIR/institution/<configured\_institution>/scripts/

The Sahara Web Interface implementation first checks in this directory for any scripts and will use them if they exist, otherwise will use the default scripts.
The mandatory rule when writing new code for the web interface is to put institution specific code into the institution directory, and use the public directory for code and images that are made available to all:
\begin{itemize}
	\item CSS files – in INSTALL\_DIR/public/css
	\item Images – in INSTALL\_DIR/public/images
	\item Javascript – in INSTALL\_DIR/js/…

	{\em move to "`tips"'}
Note: In referencing the files that the web browser must load, use is made of the baseUrl() function.  The function baseUrl() will return the preceding virtual directory of URLs, allowing the correct relative path of resources to be set for the browser to load (even if the site is in a virtual directory and not the document root).   For example, to call a CSS file: \\
	\$this->baseUrl(‘css/info.css’)
baseUrl() is a view helper and must be called from a Zend\_View instance.
\end{itemize}

\section{Rig Client Development Approach}
Once the design considerations above have been defined, the development approach for the rig client (according to this document) can be determined.  Based on the results from the questions above, the rigs can be categorised into one of three main categories of rig clients.

{\bf Peripheral control rig:} This is a rig that is controlled only by another control application.  In this case, all that needs to be defined are the actions (classes implementing a specific 'IAction' interface) that will be used for access, notification, testing, reset and activity detection.

{\bf Rig with primitive (synchronous) control:} This is a rig that includes control directly to the rig through the Rig Client. This can be control directly to the hardware (eg turning on ports on a LabJack) or as an intermediary between the WI and the program that communicates directly with the hardware (eg interfacing between the WI and a LabView web service).  In this case, the “translation” of user commands to the physical rig must be implemented. This is done in addition to defining the actions required for access, notification, testing, reset and activity detection.

{\bf Rig with batch mode control:}
 This is a rig that includes control of the rig by an uploaded file which is not bound to the users presence (i.e. can be run later as a batch job after the user has logged out). In this case, the developer needs to specify how the file is verified, what command is invoked on the uploaded file, what actions to perform before and after executing the file etc.  This is done in addition to defining the actions required for access, notification, testing, reset and activity detection.

For all development categories, the library of existing actions should be investigated to see if it holds actions that are required.  If the actions already exist (e.g. access to a remote desktop, testing network connection) they can be used by the developer.

\section{Rig Client Structure}
Every new rig is described by a deployment of the rig client.  At its most basic, this provides an interface to the rig and allows the rigs to provide the information it requires to the scheduling server (eg name, rig type, rig capabilities), for sessions to be started, stopped and monitored, and for the rig to be “exercised”.  These functions are described by the IRig interface.  
Each rig type requires its own rig client which specifies the actions associated with the particular rig type. For most types of rigs this can be done through the use of a derivation of the AbstractRig class which implements the IRig interface. 

The Sahara rig client development has favoured the use of re-usable classes which are collated into the rig client commons project.  The AbstractRig class enables this by creating an rig class that needs only the users action classes to be written and specified.  The tasks of registering actions, “executing” actions and implementing the IRig interface, are done.  Please see Figure 2 below for the structure of the classes.

A number of different rig type classes exist which extend this AbstractRig:
\begin{itemize}
	\item AbstractControlledRig (an abstract rig type class) – also implements the rig client control interface.
	\item ConfiguredRig (a concrete rig type class) – uses configuration to decide which classes to use 
	\item ConfiguredControlledRig (a concrete rig type class) – also implements the rig client control interface and uses configuration to decide which classes to use
\end{itemize}

The AbstractRig class contains (among other things) a list of the actions for that rig type under the following categories:
\begin{itemize}
	\item Access actions (IaccessAction)
	\item Slave Access Actions (ISlaveAccess)
	\item Reset actions (IResetAction)
	\item Notification actions (INotifyAction)
	\item Test actions (ITestAction)
	\item Activity detection actions (IActivityDetectorAction)
\end{itemize}

The rig type classes and actions are described in the later in this document.

\section{Rig Type Classes}
There are three rig type classes that have been written to assist in implementing the rig client.  Each of these include functionality and methods for a more specific type of rig client than the AbstractRig alone.  These correspond to the different rig types categories described in the chapter on Development Approach.  Please see figure below for the class diagram showing the relationship between the abstract and concrete classes.

{\em change and add figure}
Figure 2: Rig Type Class Diagram

\subsection{AbstractControlledRig}
The AbstractControlledRig is used to for rigs which require primitive control. In this case, the rig can be directly controlled using the rig client.  The AbstractControlledRig class sets up the primitive Front Controller for the rig type to route primitive control requests.  This rig type class also includes batch control. (Primitive control functionality is described below).  This is an abstract class that requires additional implementation to be used for a Rig Client

\subsection{ConfiguredRig}
The ConfiguredRig is used to for rigs which have peripheral control.  This rig type class allows the user to specify which actions to load. It is most suitable when all the functionality can easily be described in actions and only peripheral control is used. (The example below for the Loaded Beam is a ConfiguredRig).  This is a concrete class that implements all the behaviour required of its underlying abstract class.  It is ready for use as a Rig Client with the necessary configuration complete.

\subsection{ConfiguredControlledRig}
The ConfiguredControlledRig is used to for rigs which require batch mode as well as having peripheral control. This rig uses a “configured batch runner” i.e. a configuration file is used at run time to specify what to run, what arguments to provide and what environment variables to set.  This is a concrete class that implements all the behaviour required of its underlying abstract class.  It is ready for use as a Rig Client with the necessary configuration complete.

If none of these rig type classes are suitable for the rig, a new rig type class can be created that extends these, the abstract classes and implements the interfaces as required.

\subsection{Rig Client Class Loading}
In order to load the correct rig type class, this must be made visible to the Rig Client and be configured in the rigclient.properties file.

Place the code containing the jar file in the INSTALL\_DIR/lib/ directory (create the directory if it does not exist).  This directory contents are iterated and any jar files found are automatically added to the  rig client classpath when the Rig Client starts. To verify the jar files are correctly added to class path, consult the rigclientservice.log file in the installation directory of the rig client. This will show each of the jar files that have been added to classpath.

If desired, explicit jar file paths can be configured using the INSTALL\_DIR/config/rigclient\_service.ini file. The Extra\_Lib property contains a semi-colon separated list of jar files to add to class path. This may be useful to allow... {\em complete here }

The property Rig\_Class should contain the fully qualified class name of the rig type class i.e. either an already configured class (eg au.edu.uts.eng.remotelabs.rigclient.rig.ConfiguredRig), or one that has been written for the rig type and is in a jar file on classpath.

\section{Action Types}
When a method is called on a rig type that extends the AbstractRig, the action list created for the corresponding category is iterated through and all the listed actions are initiated. For example, when a session ends and the tests action need to be executed, the startTest method will be called which will execute in order all the test actions that have previosuly been registered by calling the ITestAction startTest method. list testActions (a list of ITestAction instances) and call the method startTest on each action listed.

{\em insert figure}
Figure 3: Rig Client action interfaces

To include a specific action in the list, they must be “registered” using the registerAction method.

If multiple actions are registered for an action type, these actions are always run sequentially. For Test, Notify, Activity Detection and Reset actions the actions are run in the order that they are registered with the Rig Client.  For Access actions, they are run in the order they are registered when assigning access to the rig, and in the reverse order when revoking access from the rig. This is to allow correct sequencing for actions that have dependencies. 

To create an action implementation, the associated interface class (eg IAccessAction or ITestAction) must be implemented.  In the future, there will be many cases where there will be existing actions that have been written for existing rigs.  These action classes can be re-used and the actions simply registered in the action lists described above.

Below are some details and specific examples of the different types of actions.

\subsection{Access Actions}
NOTE: In writing the access actions, keep in mind that in Sahara 2.0, the rig client allocation communication is synchronous and the rig client waits for the results of all the access action.  For this reason, access actions should complete quickly.  Any deadlocking of an access action will deadlock the rig client.  In future releases, this will be changed to provide the option to use callback allocation communication.

The access actions of assign and revoke must be written into a class that implements the IAccessAction interface. Attention should be paid to the order that access actions need to be executed: these actions are run in the order they are registered with the rig client when assigning access to the rig, and in the reverse order when revoking access from the rig.

See the example for RemoteDesktopAccessAction.   

\subsection{Test Actions}
NOTE: Test actions should run in their own threads.

For test actions, the methods startTest and stopTest must be written in a class that implements the runnable interface ITestAction. In addition, the methods getStatus, getReason and setInterval must be implemented.  For this, the class AbstractTestAction has been written which uses a run flag to implement ITestAction.run and set up a persistent daemon thread that exists for the life of the rig client.  This class also introduces a number of flags that can be used to tune test execution periodicity:
\begin{itemize}
	\item isPeriodic - Specifies if the test interval is periodic or if it runs at a random interval.. Generally tests which result in visible effects (i.e. something moves) should not be periodic to mimic 	real lab use (not everything lab runs at the same time). The default is for tests to be periodic.
	\item isSetIntervalHonoured - Specifies if the test interval is honoured if set to a different value. The default is to honour the test interval. 
	\item doLightDarkSchedule - Specifies if the test run interval is reduced at night time. 
\end{itemize}

A detailed description of the implementation of the Ping Test is given below; the principles apply to the other tests as well.

\subsection{Notify Actions}
The INotifyAction interface must be implemented and the notify(message, users) method implemented in order to produce messages where the users focus is, for example on the users Remote Desktop session for Remote Desktop type experiments. 

See example below.

\subsection{Activity Detection Actions}
IActivityDetectionAction interface must be implemented and the detectActivity() method written.  For example, this can be done with RDPActivityDetectorAction.

\subsection{Reset Actions}
IResetAction interface must be implemented and the reset() method coded. For example, this reset action could power down the rig, then power it back up, to return the rig to a known, safe state.

\section{Rig States}
During operation, the Rig Client can be in various states that describe its life cycle.  Please see the diagram below for a description of these states and transition. 

{\em update and include diagram}
Figure 4: Rig Client state diagram

